Υλοποίηση βελτιστοποιήσεων στον μεταγλωττιστή του μαθήματος "Γλώσσες και Μεταφραστές",
για την εργασία του μαθήματος "Αρχιτεκτονική Η/Υ"

Ο κώδικας βρίσκεται στον φάκελο src/

Βελτιστοποιήσεις ανά Αρχείο::Συνάρτηση :

1. statements.c::statement_if()
   δομή if statement:
        if (cond)
           TRUE_STMT;
        else
           FALSE_STMT;

   εαν δεν υπάρχουν τα TRUE_STMT και FALSE_STMT, το if statement παραλείπεται εντελώς.
   εάν υπάρχει μόνο το FALSE_STMT, γίνεται αντιστροφή του condition και το FALSE_STMT
   μετατρέπεται σε TRUE_STMT.
   Με αυτον τον τρόπο παράγεται τελικός κώδικας με λιγότερα άλματα:

      cond = NOT cond;
      TRUE_STMT = FALSE_STMT;
      FALSE_STMT = NULL;  //ignore

   Επίσης εαν η τιμή του condition είναι γνωστή την στιγμή της μεταγλώττισης,
   παράγουμε κατευθείαν τον κατάλληλο κλάδο της διακλάδωσης χωρίς έλεγχο κατα
   το runtime. Εαν ο κατάλληλος κλάδος δεν υπάρχει, η διακλάδωση αγνοείται εντελώς.



2. statements.c::statement_assignment()
   εάν η πρώτη ανάθεση τιμής σε μεταβλητή είναι γνωστή την στιγμή της μεταγλώττισης,
   η ανάθεση αγνοείται και η τιμή γράφεται στο .data segment του τελικού κώδικα.
   Μόνο εαν είναι ασφαλής μια τέτοια μετατροπή.



3. ir_toolbox.c::optimize_math()
   μετατροπή αργών εντολών (mult/div) στις αντίστοιχες γρήγορες εντολές ολίσθησης
   (shift left/right) για εκφράσεις που περιέχουν δυνάμεις του 2.



4. ir_toolbox.c::eliminate_notop_from_ir_cond()
   απλοποίηση condition, πχ. ο παρακάτω ψευδοκώδικας

              if (NOT (NOT a AND NOT b) )

   μετατρέπεται σε

              if (a OR B)

   Εαν το condition είναι πολύπλοκο, με αυτόν τον τρόπο το κάνουμε όσο πιο απλό γίνεται.



5. final_code.c::reuse_and_rename()
   επαναχρησιμοποίηση των ήδη διαβασμένων απο την μνήμη τιμών, από τους καταχωρητές
   όπου ήδη βρίσκονται. Η τιμή αποθηκεύεται σε νέο καταχωρητή και ο παλιός καταχωρητής
   ελευθερώνεται (rename).



6. expr_toolbox.c::expr_from_variable()
   προώθηση τιμής μεταβλητής εάν είναι γνωστή εκείνη τη στιγμή
   (αποφυγή φόρτωσης από την μνήμη)



7. expr_toolbox.c::expr_distribute_inop_to_set()
   επιμέριση του τελεστή IN για έλεγχο ύπαρξης τιμής σε SET πχ.

   ο παρακάτω ψευδοκώδικάς

          tmp_boolean := sample IN (set1 + set2 * set3 - set4)

   μετατρέπεται σε

          tmp_boolean := (sample IN set1) OR
                         ((sample IN set2) AND (sample IN set3)) AND NOT
                         (sample IN set4)

   με αυτόν τον τρόπο αποφεύγουμε την δημιουργία bitmap στην περίπτωση που
   κάποιο απο τα set[1234] είναι της μορφής [val1,val2,...,valx]

   ΣΗΜΕΙΩΣΗ:
        Οι πράξεις με bitmaps δεν υποστηρίζονται πλήρως και η δημιουργιά των
        bitmaps γίνεται με μη βέλτιστο τρόπο. Επίσης δεν έχουν γίνει εκτενή
        τεστ για την χρησιμότητα της. Στο μέλλον ίσως αυτή η τεχνική
        να αποτελεί regression και να αφαιρεθεί.



8. expr_toolbox.c::make_array_bound_check()
   static checks όταν η τιμή του index είναι γνωστή κατα την μεταγλώττιση



9. expr_toolbox.c::expr_replace_var_with_hardcoded_int()
   αντικατάσταση lvalue με την αποθηκεθμένη τιμή της, χρήσιμη για την δημιουργία
   prologue/epilogue για symbolic loop unrolling (software pipelining) όπου
   η τιμή της μεταβλητής βρόχου έιναι γνωστή.



10. expressions.c::expr_simplify_hardcoded()
    απλοποίηση εκφράσεων που περιέχουν hardcoded values, πχ.

    ο παρακάτω ψευδοκώδικας

        x := 4 + 7;

    μετατρέπεται σε

        x := 11;

